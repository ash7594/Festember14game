<html>
<head>
<!--Gravity (Festember14 Game) 18 July 2014 1300-->
</head>	

<style>

*{
	padding: 0px;
	margin: 0px;
}

body{
	background-color: #222222;
}

#canvas{
	background-color: #000000;
	border-radius: 20px;
	border: 5px solid #666666;
}

</style>

<body>

<canvas id="canvas"></canvas>
 
<script>

var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");

canvas.width = window.innerWidth * 0.9;
canvas.height = window.innerHeight * 0.9;
canvas.style.position = "absolute";
canvas.style.left = (window.innerWidth-canvas.width)/2;
canvas.style.top = (window.innerHeight-canvas.height)/2;

//////////////////
var visibleRange = 180;
var scaleVal = 3;
var gravityX = canvas.width/2;
var gravityY = canvas.height/2;
var initialRad = 150*scaleVal;
var spacing = 100*scaleVal;
//////////////////
var entity;
var jumpToggle = -1;
var acc = 0.5;
var maxSpeed = 2.5;
var entityRad = 10*scaleVal;
var entityIX = gravityX;
var entityIY = gravityY;
//var entityIY = gravityY - initialRad - entityRad;
//////////////////
var currentRad = initialRad;
//////////////////
var keys = [];
var numRings = 3;
//////////////////
var viewPortX = gravityX;
var viewPortY = gravityY - initialRad - entityRad;
//////////////////
var holeAngle = Math.random()*360;
var holeX = 0;
var holeY = 0;
//////////////////

document.addEventListener("keydown", function (e) {
    console.log(e.keyCode);
    keys[e.keyCode] = true;
    if(e.keyCode == 32) {
    	if(jumpToggle == -1) {
    		jumpToggle = 1;
    	} else if(jumpToggle == 2) {
    		jumpToggle = 0;
    	} 
    }
});
document.addEventListener("keyup", function (e) {
    //console.log(e.keyCode);
    keys[e.keyCode] = false;
});

function renderBackground() {
	var iniRad = initialRad;
	for(var i=0;i<numRings;i++) {
		ctx.beginPath();
		ctx.fillStyle="rgba(0,0,0,1)";
		ctx.arc(gravityX,gravityY,iniRad,0,2*Math.PI);
		ctx.stroke();
		ctx.closePath();
		iniRad += spacing;
	}
}

function circleEntity(x,y,r,f,v,a) {
	this.posX = x;
	this.posY = y;
	this.rad = r;
	this.color = "rgba(0,0,0,1)";
	this.friction = f;
	this.v = v;
	this.a = a;
}

function entitySpawn() {
	//ctx2.scale(2,2);
	entity = new circleEntity(entityIX,entityIY,entityRad,0.98,0,90);
}

function entityMoveAngular() {
	if(keys[37]) {
		if(entity.v > -1*maxSpeed) {
			entity.v -= acc;
		}
	} 
	if(keys[39]) {
		if(entity.v < maxSpeed) {
			entity.v += acc;
		}
	}
	if(jumpToggle == 1) {
		if(currentRad < (initialRad + spacing - 2*entity.rad)) {
			currentRad += 5;
		} else {
			jumpToggle = 2;
		}
	} else if(jumpToggle == 0) {
		if(currentRad > initialRad) {
			currentRad -= 5;
		} else {
			jumpToggle = -1;
		}
	}

	entity.v *= entity.friction;
	entity.a += entity.v;
	entity.posX = gravityX + (currentRad+entity.rad) * Math.cos(entity.a * Math.PI/180);
	entity.posY = gravityY + (currentRad+entity.rad) * Math.sin(entity.a * Math.PI/180);
}

function entityMoveTranslation() {
	if(keys[37]) {
		if(entity.v > -1*maxSpeed) {
			entity.v -= acc;
		}
	} 
	if(keys[39]) {
		if(entity.v < maxSpeed) {
			entity.v += acc;
		}
	}
	if(jumpToggle == 1) {
		if(currentRad < (initialRad + spacing - 2*entity.rad)) {
			currentRad += 5*scaleVal;
		} else {
			jumpToggle = 2;
		}
	} else if(jumpToggle == 0) {
		if(currentRad > initialRad) {
			currentRad -= 5*scaleVal;
		} else {
			jumpToggle = -1;
		}
	}

	entity.v *= entity.friction;
	entity.a += entity.v * ((initialRad+entity.rad)/(currentRad+entity.rad));
	entity.posX = gravityX + (currentRad+entity.rad) * Math.cos(entity.a * Math.PI/180);
	entity.posY = gravityY + (currentRad+entity.rad) * Math.sin(entity.a * Math.PI/180);

	/*entity.v *= entity.friction;
	entity.posX += entity.v;
	entity.a = Math.acos((entity.posX - gravityX)/(currentRad+entity.rad))/Math.PI*180;
	entity.posY = gravityY + (currentRad+entity.rad) * Math.sin(entity.a * Math.PI/180);
	*/
}

function entityRender() {
	ctx.beginPath();
	ctx.fillStyle = entity.color;
	ctx.arc(entity.posX,entity.posY,entity.rad,0,2 * Math.PI);
	ctx.fill();
	ctx.closePath();
}

function gameFocus1() {
	var imageData = ctx.getImageData(entity.posX-canvas2.width/4,entity.posY-canvas2.height/4,canvas2.width/2,canvas2.height/2);
	ctx3.clearRect(0,0,canvas3.width,canvas3.height);
	canvas3.width = imageData.width;
	canvas3.height = imageData.height;
	ctx3.putImageData(imageData,0,0);
	ctx2.drawImage(temp_canvas,0,0);
}

function gameFocus2() {
	var x = initialRad;
	var b =	(currentRad+entity.rad) - x + (canvas2.height/4);
	var a = (currentRad+entity.rad) - x + (canvas2.width/4);
	//console.log(a+" "+b+" ");
	var focusX = gravityX + a * Math.cos(entity.a * Math.PI / 180);
	var focusY = gravityY + b * Math.sin(entity.a * Math.PI / 180);
	var imageData = ctx.getImageData(focusX-canvas2.width/4,focusY-canvas2.height/4,canvas2.width/2,canvas2.height/2);
	ctx3.clearRect(0,0,canvas3.width,canvas3.height);
	canvas3.width = imageData.width;
	canvas3.height = imageData.height;
	ctx3.putImageData(imageData,0,0);
	ctx2.drawImage(temp_canvas,0,0);
}

function viewPort1() {
	if(keys[37]) {
		if(entity.v > -1*maxSpeed) {
			entity.v -= acc;
		}
	} 
	if(keys[39]) {
		if(entity.v < maxSpeed) {
			entity.v += acc;
		}
	}
	if(jumpToggle == 1) {
		if(currentRad < (initialRad + spacing - 2*entity.rad)) {
			currentRad += 5*scaleVal;
		} else {
			jumpToggle = 2;
		}
	} else if(jumpToggle == 0) {
		if(currentRad > initialRad) {
			currentRad -= 5*scaleVal;
		} else {
			jumpToggle = -1;
		}
	}

	entity.v *= entity.friction;
	entity.a += entity.v * ((initialRad+entity.rad)/(currentRad+entity.rad));
	viewPortX = gravityX + (currentRad+entity.rad) * Math.cos(entity.a * Math.PI/180);
	viewPortY = gravityY + (currentRad+entity.rad) * Math.sin(entity.a * Math.PI/180);
}

function viewPort2() {
	if(keys[90]) {              /////////// zoom out
		if(scaleVal>0.5) {
			currentRad /= scaleVal;
			scaleVal -= 0.1;
			currentRad *= scaleVal;
			initialRad = 150*scaleVal;
			spacing = 100*scaleVal;
			entity.rad = 10*scaleVal;
			entityRad = 10*scaleVal;
		}
	}
	if(keys[88]) {              /////////// zoom in
		if(scaleVal<3) {
			currentRad /= scaleVal;
			scaleVal += 0.1;
			currentRad *= scaleVal;
			initialRad = 150*scaleVal;
			spacing = 100*scaleVal;
			entity.rad = 10*scaleVal;
			entityRad = 10*scaleVal;
		}
	}
	if(keys[37]) {
		if(entity.v > -1*maxSpeed) {
			entity.v -= acc;
		}
	} 
	if(keys[39]) {
		if(entity.v < maxSpeed) {
			entity.v += acc;
		}
	}
	if(jumpToggle == 1) {
		if(currentRad < (initialRad + spacing - 2*entity.rad)) {
			currentRad += 5*scaleVal;
		} else {
			currentRad = (initialRad + spacing - 2*entity.rad);
			jumpToggle = 2;
		}
	} else if(jumpToggle == 0) {
		if(currentRad > initialRad) {
			currentRad -= 5*scaleVal;
		} else {
			currentRad = initialRad;
			jumpToggle = -1;
		}
	}

	entity.v *= entity.friction;
	entity.a += entity.v * ((initialRad+entity.rad)/(currentRad+entity.rad));
	//viewPortX = gravityX + (currentRad+entity.rad) * Math.cos(entity.a * Math.PI/180);
	//viewPortY = gravityY + (currentRad+entity.rad) * Math.sin(entity.a * Math.PI/180);

	var x = 200;
	var b =	(currentRad+entity.rad);// + (canvas.height/2);
	var a = (currentRad+entity.rad) + x;// + (canvas.width/2);
	//console.log(a+" "+b+" ");
	viewPortX = gravityX + a * Math.cos(entity.a * Math.PI / 180);
	viewPortY = gravityY + b * Math.sin(entity.a * Math.PI / 180);
	holeX = viewPortX + (initialRad + spacing)*Math.cos(holeAngle * Math.PI / 180);
	holeY = viewPortY + (initialRad + spacing)*Math.sin(holeAngle * Math.PI / 180);
	entity.posX = gravityX + (currentRad+entity.rad-a) * Math.cos((entity.a-180) * Math.PI / 180);
	entity.posY = gravityY + (currentRad+entity.rad-b) * Math.sin((entity.a-180) * Math.PI / 180);
}

function renderBack() {
	ctx.fillStyle="rgba(0,0,0,1)";
	for(var i=initialRad;i<=currentRad+(numRings*spacing);i+=spacing) {
		if((i+spacing)>=currentRad) {
			ctx.beginPath();
			ctx.arc(viewPortX,viewPortY,i,(entity.a-180-visibleRange)*Math.PI/180,(entity.a-180+visibleRange)*Math.PI/180);
			ctx.stroke();
			ctx.closePath();
		}
	}
}

function renderBack2() {
	ctx.fillStyle="rgba(255,255,255,1)";
	for(var i=initialRad;i<=currentRad+(spacing);i+=spacing) {
		if((i+spacing)>=currentRad) {
			ctx.beginPath();
			ctx.moveTo(viewPortX+(i+spacing)*Math.cos((entity.a-180-visibleRange)*Math.PI/180),viewPortY+(i+spacing)*Math.sin((entity.a-180-visibleRange)*Math.PI/180));
			ctx.arc(viewPortX,viewPortY,i,(entity.a-180-visibleRange)*Math.PI/180,(entity.a-180+visibleRange)*Math.PI/180,false);
			//ctx.lineTo(viewPortX+(i+spacing)*Math.cos((entity.a-180-visibleRange)*Math.PI/180),viewPortY+(i+spacing)*Math.sin((entity.a-180-visibleRange)*Math.PI/180));
			ctx.arc(viewPortX,viewPortY,i+spacing,(entity.a-180+visibleRange)*Math.PI/180,(entity.a-180-visibleRange)*Math.PI/180,true);
			//ctx.lineTo(viewPortX+(i)*Math.cos((entity.a-180-visibleRange)*Math.PI/180),viewPortY+(i)*Math.sin((entity.a-180-visibleRange)*Math.PI/180));
			ctx.closePath();
			ctx.fill();
			break;
		}
	}
}

function createHole() {
	holeAngle = Math.random()*360;
}

function renderHole() {
	ctx.beginPath();
	ctx.fillStyle = "red";
	ctx.arc(holeX,holeY,10,0,2*Math.PI);
	ctx.fill();
	ctx.closePath();
}

function gameState() {
	//ctx.fillStyle="rgba(255,255,255,0.8)";
	//ctx.fillRect(0,0,canvas.width,canvas.height);
	ctx.clearRect(0,0,canvas.width,canvas.height);
	//ctx2.clearRect(0,0,canvas2.width,canvas2.height);
	/*if(initialRad < 2) {
		initialRad += spacing - 2;
		currentRad += spacing - 2; 
	} else {
		initialRad -= 2;
		currentRad -= 2;
	}*/

	//renderBackground();
	//entityMoveAngular();
	//entityMoveTranslation();
	viewPort2();
	renderBack2();
	entityRender();
	renderHole();
	//gameFocus1();
	//gameFocus2();
	//gameFocus3();
	setTimeout(function(){gameState();},17);
}

entitySpawn();
//entityRender();
gameState();

</script>
</body>
</html>